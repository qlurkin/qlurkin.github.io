<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chapitre 1 - La programmation</title>
    <script src="/document.js" defer></script>
    
</head>
<body>
    <h1>Chapitre 1 <small>La programmation</small></h1>
    
    <script type="module" defer>
Doc.setChapterNb(1)
</script>

<h2>Qu&#39;est-ce qu&#39;un programme?</h2>
<p>De mani√®re g√©n√©rale, un programme est une suite d&#39;actions √† entreprendre visant
√† atteindre un but. On peut par exemple dire d&#39;une recette de cuisine que c&#39;est
un programme pour r√©aliser un plat (cf <span data-link='oeuf'>figure</span>). On
parle √©galement de programme pour un lave-linge o√π, suivant le type de linge, la
suite d&#39;actions (rotations du tambour) est diff√©rente.</p>
<figure id='oeuf' data-ref='figure'>
    <div></div>
    <figcaption>Cuire un ≈ìuf</figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#oeuf > div', 350, 500)
    const start = draw.start().move(1, 2)
    const hot = draw.round('faire chauffer la po√™le').belowOf(start)
    const oil = draw.round('mettre de l\'huile dans la po√™le').belowOf(hot)
    const egg = draw.round('casser l\'≈ìuf dans la po√™le').belowOf(oil)
    const salt = draw.round('ajouter du sel et du poivre').belowOf(egg)
    const dummyTop = draw.dummy().belowOf(salt)
    const cooked = draw.round('Est-ce que c\'est cuit ?').belowOf(dummyTop)
    const if1 = draw.diamond().belowOf(cooked)
    const non = draw.node('non').belowOf(if1)
    const wait = draw.round('On attend 10 secondes').belowOf(non)
    const oui = draw.node('oui').absolute(if1, 50, 0)
    const dummyRight = draw.dummy().rightOf(wait)
    const dummyLeft = draw.dummy().leftOf(if1)
    const end = draw.end().belowOf(wait)
    draw.polyline([start, '-->', hot, '-->', oil, '-->', egg, '-->', salt, '--', dummyTop, '-->', cooked, '-->', if1])
    draw.polyline([if1, '', non, '-->', wait, '-|', dummyLeft, '|->', dummyTop])
    draw.polyline([if1, '', oui, '-|', dummyRight, '|->', end])
    draw.done()
</script>

<p>Un programme est donc constitu√© d&#39;une suite d&#39;instructions √† ex√©cuter dans un
certain ordre.</p>
<p>Dans le domaine de l&#39;informatique, un programme est une suite d&#39;instructions
visant √† la r√©solution d&#39;un probl√®me. La r√©solution d&#39;une √©quation du deuxi√®me
degr√© que vous avez apprise en secondaire ressemble d√©j√† beaucoup √† un programme
informatique (cf <span data-link='d2deg'>figure</span>).</p>
<figure id='d2deg' data-ref='figure'>
    <div></div>
    <figcaption>Second degr√©</figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#d2deg > div', 600, 600)
    const start = draw.start()
    const delta = draw.round('calculer <code>b*b-4*a*c</code> et appeler le r√©sultat D').belowOf(start)
    const test_delta = draw.round('Est-ce que D est n√©gatif ?').belowOf(delta)
    const if1 = draw.diamond().belowOf(test_delta)
    const oui1 = draw.node('oui').absolute(if1, 50, 0)
    const non1 = draw.node('non').belowOf(if1)
    const test_null = draw.round('Est-ce que D est nul ?').belowOf(non1)
    const if2 = draw.diamond().belowOf(test_null)
    const oui2 = draw.node('oui').absolute(if2, 50, 0)
    const non2 = draw.node('non').belowOf(if2)
    const root1 = draw.round('La 1<sup>re</sup> racine est <code>(-b+sqrt(D))/(2*a)</code>').belowOf(non2)
    const root2 = draw.round('La 2<sup>e</sup> racine est <code>(-b-sqrt(D))/(2*a)</code>').belowOf(root1)
    const dummy = draw.dummy().belowOf(root2)
    const end = draw.end().belowOf(dummy)
    const noroot = draw.round('Pas de racine r√©elle').width(150).absolute(test_null, 270, -30)
    const droot = draw.round('La racine double est <code>-b/(2*a)</code>').width(150).absolute(if2, 170, 0)
    draw.polyline([start, '-->', delta, '--', test_delta, '-->', if1, '--', non1, '--', test_null, '-->', if2, '--', non2, '--', root1, '--', root2, '--', dummy, '-->', end])
    draw.polyline([if2, '--', oui2, '-->', droot, '|->', dummy])
    draw.polyline([if1, '--', oui1, '-|>', noroot, '|-', dummy])
    draw.done()
</script>

<h3>Code et langage de programmation</h3>
<p>Les figures <span data-link='oeuf'></span> et <span data-link='d2deg'></span>
sont des repr√©sentations graphiques de programmes. On les appelle organigrammes
ou encore diagrammes d&#39;activit√©. Un vrai programme se fait dans un langage de
programmation. Un programme √©crit dans un langage de programmation se pr√©sente
donc comme du texte. Ce texte est appel√© le code source du programme.</p>
<p>Une fa√ßon d&#39;√©crire en texte le programme de r√©solution d&#39;une √©quation du second
degr√© pourrait √™tre la suivante :</p>
<figure id="code_2deg" data-ref='code'>

<pre>
b*b-4*a*c <strong>&#8594;</strong> D
<strong>si</strong> D &lt; 0 <strong>alors:</strong>
    <strong>affiche</strong> <span class='hljs-string'>"Pas de solution r√©elle"</span>
<strong>sinon:</strong>
    <strong>si</strong> D = 0 <strong>alors:</strong>
        <strong>affiche</strong> <span class='hljs-string'>"La racine double est"</span> -b/(2*a)
    <strong>sinon:</strong>
        <strong>affiche</strong> <span class='hljs-string'>"La 1<sup>re</sup> racine est"</span> (-b-sqrt(D))/(2*a)
        <strong>affiche</strong> <span class='hljs-string'>"La 2<sup>e</sup> racine est"</span> (-b+sqrt(D))/(2*a)
</pre>

<figcaption>Pseudo code, second degr√©</figcaption>
</figure>

<p>Le texte ci-dessus est souvent appel√© &quot;pseudo-code&quot; car il a une structure tr√®s
proche d&#39;un vrai code de programme mais il n&#39;est √©crit dans aucun langage de
programmation particulier.</p>
<p>Pour √©crire un vrai programme, il faut choisir un langage de programmation et
respecter sa syntaxe. Le langage que nous allons utiliser dans ce cours est le
<strong>Python</strong>. Voici la version Python du pr√©c√©dent pseudo-code:</p>
<figure id='python_2deg' data-ref='code'>

<pre><code class="language-python">D = b*b-4*a*c
if D &lt; 0:
    print(&quot;Pas de solution r√©elle&quot;)
else:
    if D == 0:
        print(&quot;La racine double est&quot;, -b/(2*a))
    else:
        print(&quot;La 1re racine est&quot;, (-b-sqrt(D))/(2*a))
        print(&quot;La 2e racine est&quot;, (-b+sqrt(D))/(2*a))
</code></pre>
<figcaption>Python, second degr√©</figcaption>
</figure>

<p>Dans un programme, chaque ligne du code est une instruction. Les instructions
sont ex√©cut√©es dans l&#39;ordre o√π elles apparaissent dans le code du programme.</p>
<p>&quot;Les instructions sont ex√©cut√©es...&quot;, mais comment sont-elles ex√©cut√©es et par
quoi&nbsp;? O√π se trouve ce fameux code du programme&nbsp;?</p>
<p>Pour bien comprendre tout cela, nous allons devoir nous int√©resser au
fonctionnement d&#39;un ordinateur.</p>
<h2>Qu&#39;est-ce qu&#39;un ordinateur ?</h2>
<p>Nous allons ici essayer de comprendre comment un ordinateur fait pour ex√©cuter
du code. Pour pouvoir programmer, nous n&#39;avons pas besoin de tout conna√Ætre dans
les d√©tails. Mais comprendre les bases du fonctionnement d&#39;un ordinateur nous
aidera pour le programmer et pour l&#39;utiliser correctement.</p>
<p>Un ordinateur est, avant tout, un syst√®me compos√© de plusieurs √©l√©ments:
processeur, m√©moire, stockage, p√©riph√©riques, ...</p>
<figure id="system" data-ref="figure">
<img src="./system.svg">
<figcaption>CPU, RAM, et stockage</figcaption>
</figure>

<h3>Le processeur</h3>
<p>Le processeur <em>(<strong>CPU</strong>: Central Processing Unit)</em> ex√©cute les instructions d&#39;un
programme une par une. Ces instructions proviennent de <strong>la m√©moire</strong>. Apr√®s
avoir ex√©cut√© une instruction, il passe automatiquement √† celle qui suit dans la
m√©moire. Certaines instructions peuvent cependant le faire sauter √† un tout
autre endroit de la m√©moire pour continuer l&#39;ex√©cution.</p>
<p>Les instructions manipulent g√©n√©ralement <strong>des donn√©es</strong>. Par exemple,
l&#39;instruction permettant d&#39;additionner va n√©cessiter d&#39;aller chercher les
valeurs √† additionner. Les donn√©es sont elles aussi en m√©moire. Et <strong>les
r√©sultats</strong> des calculs sont eux aussi sauv√©s en m√©moire une fois qu&#39;ils ont √©t√©
calcul√©s.</p>
<p>En bref, le processeur est donc grosso-modo capable de deux choses: calculer et
sauver/lire des valeurs en m√©moire.</p>
<p>Encore une petite remarque √† propos du processeur : il ne comprend que le
langage pour lequel il a √©t√© con√ßu. On appelle ce langage <strong>le jeu
d&#39;instructions du processeur</strong> ou encore <strong>langage machine</strong>. Il existe des jeux
d&#39;instructions diff√©rents pour chaque architecture de processeur (x86, ARM,
...).</p>
<h3>La m√©moire</h3>
<p>La m√©moire <em>(<strong>RAM</strong>: Random Access Memory)</em> contient <strong>les instructions</strong> du
programme et <strong>les donn√©es</strong> qu&#39;il manipule. Sa taille ne d√©passe g√©n√©ralement
pas quelques giga-octets (Go).</p>
<p>On peut se repr√©senter la m√©moire comme une longue liste de cases ayant chacune
un num√©ro. Lorsque le processeur veut obtenir une instruction ou une donn√©e en
m√©moire, il doit mentionner le num√©ro de la case qu&#39;il souhaite consulter.</p>
<p>Pour garder ses donn√©es, la m√©moire a besoin d&#39;√™tre aliment√©e ce qui veut dire
que le contenu de la m√©moire est perdu si on lui coupe le courant. On dit que la
m√©moire est <strong>volatile</strong>.</p>
<p>Quand nous √©crirons des programmes, nous manipulerons beaucoup la m√©moire par
l&#39;interm√©diaire <strong>des variables</strong>.</p>
<h3>Le stockage</h3>
<p>Puisque la m√©moire est volatile et limit√©e en taille, comment stocke-t-on de
grandes quantit√©s de donn√©es et comment fait-on quand on √©teint l&#39;ordinateur ?
On utilise un <strong>stockage de masse</strong>.</p>
<p>Il en existe plusieurs sortes&nbsp;:</p>
<ul>
<li>disque <strong>SSD</strong> (Solid State Drive)</li>
<li>disque dur (<strong>HDD</strong>: Hard Disk Drive)</li>
<li>cl√© <strong>USB</strong> (Universal Serial Bus)</li>
<li>carte <strong>SD</strong> (Secure Digital)</li>
<li>...</li>
</ul>
<p>Le stockage de masse contient <strong>des fichiers</strong> et <strong>des r√©pertoires</strong>. Un
r√©pertoire peut contenir plusieurs fichiers et plusieurs autres r√©pertoires. Le
contenu du stockage de masse est donc organis√© en une <strong>hi√©rarchie</strong> de
r√©pertoires et chaque √©l√©ment dans cette hi√©rarchie peut √™tre localis√© par son
<strong>chemin d&#39;acc√®s</strong>. Le chemin d&#39;acc√®s est constitu√© de la suite de r√©pertoires √†
ouvrir pour atteindre l&#39;√©l√©ment.</p>
<p>Exemple:</p>
<ul>
<li>sous Windows: C:\Users\lur\Documents\note.txt</li>
<li>sous MacOS: /Users/lur/note.txt</li>
</ul>
<p>Lorsqu&#39;un programme doit √™tre ex√©cut√©, ses instructions se trouvent initialement
dans un fichier dans le stockage de masse. Les fichiers contenant des
instructions pour le processeur sont appel√©s des <strong>fichiers ex√©cutables</strong> (sous
Windows, on les reconna√Æt car leurs noms finissent par &quot;.exe&quot;). Pour ex√©cuter un
de ces fichiers, le <strong>syst√®me d&#39;exploitation</strong> (<strong>OS</strong>: Operating System) va
d&#39;abord le <strong>copier</strong> dans la m√©moire. Le processeur pourra alors commencer √† en
ex√©cuter les instructions.</p>
<p>De m√™me, pour qu&#39;un programme en cours d&#39;ex√©cution puisse acc√©der au contenu
d&#39;un fichier, il devra d&#39;abord le <strong>charger</strong> en m√©moire.</p>
<p>Les op√©rations d&#39;√©criture et de lecture de fichiers sont beaucoup plus
<strong>lentes</strong> que les acc√®s √† des donn√©es en RAM. Les stockages de masse n&#39;ont pas
besoin d&#39;√™tre aliment√©s pour conserver les donn√©es (ils sont <strong>persistants</strong>) et
peuvent contenir jusqu&#39;√† plusieurs tera-octets (<strong>To</strong>&nbsp;:&nbsp;~1000 Go).</p>
<p>Comme nous l&#39;avons vu, un programme se pr√©sente en pratique comme un simple
texte et nous sauverons ce texte dans un fichier.</p>
<h2>Langage de programmation</h2>
<p>Les fichiers contenant des programmes contiennent les instructions du programme
dans <strong>le langage propre au processeur</strong>. Par exemple, le jeu d&#39;instructions des
processeurs x86 <em>(i3, i5, i7, amd ryzen, ...)</em> est compl√®tement diff√©rent de
celui des processeurs ARM <em>(Apple Silicon, Snapdragon, ...)</em>.</p>
<p>Ces jeux d&#39;instructions sont faits pour s&#39;ex√©cuter aussi efficacement que
possible par le processeur. Mais ils sont particuli√®rement difficiles √† lire et
√† √©crire par un √™tre humain.</p>
<p>Pour cr√©er un programme, on passe donc g√©n√©ralement par <strong>un langage de
programmation</strong>.</p>
<p>Un langage de programmation est fait pour √™tre <strong>√©crit</strong> et <strong>lu</strong> par un √™tre
humain. Le code source d&#39;un programme est un <strong>simple fichier texte</strong>. Le code
source doit ensuite √™tre traduit en langage machine pour pouvoir √™tre ex√©cut√©
par le processeur. En fonction du moment o√π cette traduction a lieu, on
distingue deux grandes familles de langage de programmation: les langages
compil√©s et les langages interpr√©t√©s.</p>
<p>Dans un <strong>langage compil√©</strong>, la traduction se fait par un programme appel√©
<strong>compilateur</strong>. Le compilateur g√©n√®re un fichier ex√©cutable √† partir du fichier
de code source. Le contenu de ce fichier ex√©cutable peut ensuite √™tre ex√©cut√©
directement par le processeur et le compilateur <strong>n&#39;est plus n√©cessaire</strong>.</p>
<p>Dans un <strong>langage interpr√©t√©</strong>, la traduction se fait par un programme appel√©
<strong>interpr√©teur</strong>. L&#39;interpr√©teur ne produit pas de fichier ex√©cutable. Il
ex√©cute directement chaque instruction qu&#39;il rencontre dans le code source. On a
donc le processeur qui ex√©cute l&#39;interpr√©teur et l&#39;interpr√©teur qui ex√©cute
notre code source. Dans ce cas, l&#39;interpr√©teur est n√©cessaire pour <strong>chaque
ex√©cution</strong> du code source.</p>
<p>Le langage que nous allons utiliser dans ce cours est un langage interpr√©t√©
nomm√© <strong>Python</strong>. Pour ex√©cuter un programme Python, il est n√©cessaire
d&#39;installer l&#39;interpr√©teur Python.</p>
<h2>Ex√©cuter mon premier programme Python</h2>
<p>La premi√®re chose √† faire est d&#39;installer l&#39;interpr√©teur Python. Pour cela, il
faut commencer par le t√©l√©charger sur <a href="https://python.org">https://python.org</a>. <strong>Attention&nbsp;:
sous Windows, cochez la case &quot;Add Python to PATH&quot; durant l&#39;installation&nbsp;!</strong></p>
<figure id="python_org" data-ref="figure">
<img src="./python.org.webp">
<figcaption>Site de Python</figcaption>
</figure>

<p>Cela fait, nous avons l&#39;interpr√©teur Python install√©. Cet interpr√©teur va nous
permettre d&#39;ex√©cuter nos programmes. Il ne va par contre pas nous aider √† √©crire
notre programme.</p>
<p>Comme le code d&#39;un programme est un simple texte, la seule chose dont on a
besoin pour √©crire un programme est un <strong>√©diteur de texte</strong> (Bloc-note sous
Windows, TextEdit sous MacOS, ...). Il est cependant plus pratique d&#39;utiliser un
√©diteur <strong>sp√©cialis√©</strong> pour √©crire le code. Ces √©diteurs facilitent fortement
l&#39;√©criture et la lisibilit√© du code (Zed, Visual Studio Code, Notepad++, Sublime
Text, ...). Dans ce cours, nous utiliserons <strong>Zed</strong> comme √©diteur.</p>
<p>Pour installer Zed, il faut le t√©l√©charger sur le site <a href="https://zed.dev/">https://zed.dev/</a>.</p>
<figure id="zed_dev" data-ref="figure">
<img src="./zed_dev.webp">
<figcaption>Site de Zed</figcaption>
</figure>

<p>Une fois Zed install√©, nous pouvons cr√©er un <strong>nouveau fichier</strong> avec le contenu
suivant&nbsp;:</p>
<figure id="helloworld" data-ref="code">

<pre><code class="language-python">print(&#39;Hello World !&#39;)
</code></pre>
<figcaption>Le fichier <code>hello.py</code></figcaption>
</figure>

<p>Une fois le code √©crit, <strong>enregistrez</strong> le fichier sous le nom <code>hello.py</code>.
Faites attention au <strong>r√©pertoire</strong> dans lequel vous sauvez votre fichier. Nous
aurons en effet besoin de conna√Ætre <strong>le chemin d&#39;acc√®s</strong> de notre fichier pour
l&#39;ex√©cuter avec l&#39;interpr√©teur Python. Le fait de faire terminer le nom du
fichier par l&#39;extension <code>.py</code> est une <strong>convention</strong> qui aide √† identifier le
<strong>type de contenu</strong> d&#39;un fichier sans avoir n√©cessairement besoin de l&#39;ouvrir.</p>
<p>Maintenant que notre fichier est cr√©√©, nous allons pouvoir l&#39;ex√©cuter avec
l&#39;interpr√©teur Python. Le probl√®me, c&#39;est que l&#39;interpr√©teur n&#39;a <strong>pas
d&#39;interface graphique</strong>&nbsp;!</p>
<p>Il est probable que la plupart des programmes que vous avez eu l&#39;habitude
d&#39;utiliser par le pass√© soient des programmes ayant une interface graphique. On
interagit g√©n√©ralement avec ce genre de programme en cliquant sur l&#39;interface
graphique avec la souris de l&#39;ordinateur. L&#39;interpr√©teur Python, lui, n&#39;a pas
d&#39;interface graphique et les programmes que nous allons cr√©er dans un premier
temps n&#39;en auront pas non plus. Il va donc falloir que nous apprenions √†
utiliser le <strong>terminal</strong> pour interagir avec des programmes en <strong>ligne de
commande</strong>.</p>
<p>Nous nous pencherons sur l&#39;utilisation du terminal dans la section suivante.
Pour le moment, nous allons essayer de lancer rapidement notre premier
programme. Lancez un terminal (Application &quot;Powershell&quot; sous Windows et
&quot;Terminal&quot; sous MacOS) et tapez <strong>la commande</strong> qui suit pour d√©marrer
l&#39;interpr√©teur avec notre fichier <code>hello.py</code>. Le chemin d&#39;acc√®s mentionn√© est
<strong>un exemple</strong>. Vous devez utiliser le chemin d&#39;acc√®s du fichier que <strong>vous avez
cr√©√© pr√©c√©demment</strong>. <strong>Attention: le premier caract√®re <code>&gt;</code> repr√©sente l&#39;invite
de commande. Vous ne devez pas le taper</strong>. Sous MacOS, vous devrez sans doute
utiliser la commande <code>python3</code> √† la place de <code>python</code>. Prenez garde aussi au
format du chemin d&#39;acc√®s; il est diff√©rent entre Windows et MacOS.</p>
<p><strong>Sous Windows&nbsp;:</strong></p>
<pre class='terminal'>
<b>> python C:\Users\lur\Documents\Programmation\hello.py</b>
</pre>

<p><strong>Sous MacOS&nbsp;:</strong></p>
<pre class='terminal'>
<b>> python3 /Users/lur/Documents/Programmation/hello.py</b>
</pre>

<p>Validez avec la touche <strong>Enter</strong>. Vous devriez maintenant voir appara√Ætre le
message <strong>&quot;Hello World !&quot;</strong> dans le terminal en dessous de la commande que vous
avez tap√©e.</p>
<p><strong>F√©licitations vous venez d&#39;ex√©cuter votre premier programme&nbsp;!</strong></p>
<p>Il faut bien avouer que taper le chemin complet du fichier est un petit peu
fastidieux. Nous allons donc essayer d&#39;en apprendre un peu plus sur le terminal
pour pouvoir l&#39;utiliser plus efficacement.</p>
<h3>Terminal</h3>
<p>Une bonne partie de l&#39;utilisation d&#39;un ordinateur passe par la cr√©ation,
l&#39;√©dition et la gestion de fichiers dans l&#39;arborescence de dossiers du stockage
de masse. Bien que de nos jours la plupart des gens fassent ces op√©rations en
utilisant une interface graphique, il est aussi possible de les r√©aliser en
<strong>ligne de commande dans un terminal</strong>.</p>
<p>Sous Windows, il y a plusieurs programmes permettant d&#39;utiliser les lignes de
commande&nbsp;:</p>
<ul>
<li>cmd: invite de commande</li>
<li>Powershell</li>
</ul>
<p>Sous MacOS, le programme s&#39;appelle simplement &quot;Terminal&quot;.</p>
<p>Les d√©veloppeurs et les ing√©nieurs sont <strong>r√©guli√®rement</strong> amen√©s √† utiliser le
terminal. Il est donc important d&#39;apprendre les bases de son utilisation.</p>
<p>La premi√®re notion √† int√©grer est la notion de <strong>r√©pertoire courant</strong>. Lorsqu&#39;on
utilise le terminal, il y a toujours un dossier de l&#39;arborescence qui est
consid√©r√© comme notre position actuelle. On peut afficher le chemin de ce
dossier avec la commande <code>pwd</code> pour <em>print working directory</em>. Beaucoup de
commandes agissent directement sur le r√©pertoire courant.</p>
<pre class="terminal">
<b>> pwd</b>
C:\Users\lur
</pre>

<p>La commande <code>ls</code> permet de <strong>lister</strong> le contenu du r√©pertoire courant.</p>
<pre class="terminal">
<b>> ls</b>
Desktop Documents
</pre>

<p>La commande <code>cd</code> (<em>change directory</em>) permet de <strong>changer le r√©pertoire
courant</strong>.</p>
<pre class="terminal">
<b>> cd Documents</b>
<b>> pwd</b>
C:\Users\lur\Documents
</pre>

<p>On indique le <strong>nouveau r√©pertoire courant</strong> par son chemin relatif ou
absolu&nbsp;:</p>
<ul>
<li><strong>Un chemin absolu</strong> indique un √©l√©ment de l&#39;arborescence de fichiers en
partant de <strong>la racine</strong> de celle-ci&nbsp;:<ul>
<li>Sous Windows&nbsp;: <code>C:\Users\lur</code></li>
<li>Sous MacOS ou Linux&nbsp;: <code>/Users/lur</code></li>
</ul>
</li>
<li><strong>Un chemin relatif</strong> l&#39;indique en partant du r√©pertoire courant. Si le
r√©pertoire courant est <code>C:\Users</code> alors le chemin relatif
<code>lur\Documents\hello.py</code> correspond au chemin absolu
<code>C:\Users\lur\Documents\hello.py</code>.</li>
</ul>
<p><strong>Remarques&nbsp;:</strong></p>
<ul>
<li>Dans un chemin, l&#39;utilisation de <code>..</code> permet de <strong>remonter</strong> d&#39;un repertoire.
La commande <code>cd ..</code> permet donc de passer au r√©pertoire <strong>parent</strong>. Un <code>.</code>
seul repr√©sente le r√©pertoire <strong>courant</strong>. Le chemin relatif mentionn√© plus
haut peut donc aussi s&#39;√©crire <code>.\lur\Documents\hello.py</code>.</li>
<li>Windows utilise des <strong>anti-slashs</strong> (<code>\</code>) pour s√©parer les diff√©rentes parties
du chemin alors que MacOS et Linux utilisent des <strong>slashs</strong> (<code>/</code>).</li>
<li>Dans la plupart des terminaux, la <strong>touche tabulation</strong> (<code>Tab ‚Üπ</code>) permet
d&#39;<strong>auto-compl√©ter</strong> les √©l√©ments des chemins.</li>
</ul>
<figure id="tab" data-ref="figure">
<img src='./keyboard.svg' class="half">
<figcaption>La touche <code>Tab</code></figcaption>
</figure>

<ul>
<li>La <strong>touche <code>&#8593;</code></strong> permet de reprendre des <strong>commandes
pr√©c√©dentes</strong>.</li>
</ul>
<p>Du coup, pour pouvoir d√©marrer notre programme Python plus facilement, il suffit
de mettre le r√©pertoire contenant le fichier <code>.py</code> comme r√©pertoire
courant&nbsp;:</p>
<pre class='terminal'>
<b>> pwd</b>
C:\Users\lur
<b>> cd Documents\Programmation</b>
<b>> pwd</b>
C:\Users\lur\Documents\Programmation
<b>> python hello.py</b>
</pre>

<p>De plus, si on souhaite relancer le programme, il suffit d&#39;appuyer sur
<code>&#8593;</code> pour r√©cup√©rer la derni√®re commande et puis de valider avec
<code>Enter</code>.</p>
<p>Sachez aussi qu&#39;il est possible d&#39;ouvrir un terminal <strong>dans l&#39;interface de
Zed</strong>. Si vous ouvrez votre r√©pertoire de travail dans Zed <em>(File &#8594;
Open...)</em>, tous les terminaux que vous ouvrirez commenceront automatiquement
avec votre r√©pertoire de travail comme r√©pertoire courant!</p>
<h3>La variable d&#39;environnement <code>PATH</code></h3>
<p>Nous avons vu plus haut que l&#39;interpr√©teur Python √©tait un programme dont les
instructions en langage machine se trouvent dans un <strong>fichier ex√©cutable</strong> nomm√©
<code>python.exe</code> (sous Windows). Mais comment fait le terminal pour savoir <strong>o√π se
trouve</strong> ce fichier ex√©cutable lorsqu&#39;on tape la commande <code>python</code>?</p>
<p>En r√©alit√©, le fichier <code>python.exe</code> peut se trouver √† plusieurs endroits. Si
vous avez fait une installation simple sous Windows, il se trouve normalement
dans&nbsp;:</p>
<p class='center'><code>C:\Users\lur\AppData\Local\Programs\Python\Python<span class="pypathversion">3XX</span>\python.exe</code></p>

<p>Et on peut d√©marrer un programme dans le terminal en utilisant ce chemin
complet&nbsp;:</p>
<pre class='terminal' style='font-size: 50%'>
<b>> C:\Users\lur\AppData\Local\Programs\Python\Python311\python.exe C:\Users\lur\Documents\Programmation\hello.py</b>
</pre>

<p>Mais ce n&#39;est pas tr√®s pratique.</p>
<p>Pour √©viter d&#39;avoir √† taper les chemins entiers des fichiers ex√©cutables, <strong>la
variable <code>PATH</code></strong> contient une <strong>liste de dossiers</strong> dans laquelle le syst√®me
d&#39;exploitation va pouvoir chercher.</p>
<p>Lors de l&#39;installation de l&#39;interpr√©teur Python, vous avez normalement coch√© la
case <strong>&quot;Add Python to PATH&quot;</strong>. Cela a fait en sorte que le programme
d&#39;installation ajoute le r√©pertoire
<code>C:\...\Python<span class="pypathversion">3XX</span></code> √† la liste de
dossiers de la variable <code>PATH</code>. Et maintenant, √† chaque fois que l&#39;on utilise la
commande <code>python</code>, le syst√®me d&#39;exploitation <strong>cherche</strong> un programme nomm√©
<code>python.exe</code> dans les dossiers list√©s <strong>dans <code>PATH</code></strong> et il le trouve dans
<code>C:\...\Python<span class="pypathversion">3XX</span></code>.</p>
<p>Pour finir, voici un sch√©ma qui r√©capitule les op√©rations qui ont lieu quand on
lance une commande (<code>python</code>) dans le terminal&nbsp;:</p>
<figure id="command" data-ref="figure">
    <div></div>
    <figcaption>Ex√©cution de la commande python par le terminal</figcaption>
</figure>
<script type="module" defer>
    const draw = await Doc.Draw('#command > div', 500, 700)
    const start = draw.start().move(1, 2)
    const command = draw.round('R√©ception de la commande <code>python hello.py</code>').belowOf(start)
    const path = draw.round('Recherche <code>python.exe</code> dans les r√©pertoires de <code>PATH</code>').belowOf(command)
    const dia1 = draw.diamond().belowOf(path)
    const found = draw.round('<code>C:\\...\\Python<span class="pypathversion">3XX</span>\\python.exe</code> trouv√©, chargement en RAM').belowOf(dia1)
    const run = draw.round('Ex√©cution de l\'interpr√©teur par le CPU').belowOf(found)
    const fetch = draw.round('L\'interpr√©teur demande √† l\'OS le fichier <code>hello.py</code>').belowOf(run)
    const file = draw.round('<code>hello.py</code> est un chemin relatif, recherche √† partir du <strong>r√©pertoire courant</strong>').belowOf(fetch)
    const dia2 = draw.diamond().belowOf(file)
    const foundpy = draw.round('<code>hello.py</code> trouv√©, chargement en RAM').belowOf(dia2)
    const running = draw.round('L\'interpr√©teur ex√©cute le code Python üôå').classes('success').belowOf(foundpy)
    const end = draw.end().belowOf(running)
    const exenotfound = draw.round('<code>python.exe</code> non trouv√©').rightOf(found)
    const error1 = draw.round('Erreur&nbsp;: commande <code>python</code> inconnue').classes('error').belowOf(exenotfound)
    const enderror1 = draw.end().belowOf(error1)
    const pynotfound = draw.round('<code>hello.py</code> non trouv√©').rightOf(foundpy)
    const error2 = draw.round('Erreur&nbsp;: fichier <code>hello.py</code> introuvable').classes('error').belowOf(pynotfound)
    const enderror2 = draw.end().belowOf(error2)
    draw.polyline([start, '-->', command, '-->', path, '-->', dia1, '-->', found, '-->', run, '-->', fetch, '-->', file, '-->', dia2, '-->', foundpy, '-->', running, '-->', end])
    draw.polyline([dia1, '-|>', exenotfound, '-->', error1, '-->', enderror1])
    draw.polyline([dia2, '-|>', pynotfound, '-->', error2, '-->', enderror2])
    draw.done()
</script>

<h2>Erreurs et d√©buggage</h2>
<p>Nous avions vu, plus haut, un exemple de programme pour r√©soudre les √©quations
du second degr√©&nbsp;:</p>
<figure id='python_2deg' data-ref='code'>

<pre><code class="language-python">D = b*b-4*a*c
if D &lt; 0:
    print(&quot;Pas de solution r√©elle&quot;)
else:
    if D == 0:
        print(&quot;La racine double est&quot;, -b/(2*a))
    else:
        print(&quot;La 1re racine est&quot;, (-b-sqrt(D))/(2*a))
        print(&quot;La 2e racine est&quot;, (-b+sqrt(D))/(2*a))
</code></pre>
<figcaption>Python, second degr√©</figcaption>
</figure>

<p>Il est maintenant temps d&#39;essayer de l&#39;ex√©cuter. Sauvez ce programme <strong>dans un
nouveau fichier</strong>, <code>2nd_order.py</code> et essayez de le lancer&nbsp;:</p>
<pre class="terminal" style="font-size: 85%">
<b>> python 2nd_order.py</b>
Traceback (most recent call last):
  File "C:\Users\lur\Programmation\2nd_order.py", line 1, in &lt;module&gt;
    D = b*b-4*a*c
        ^
NameError: name 'b' is not defined
</pre>

<p>Il semblerait que quelque chose se soit mal pass√©. Ce que nous avons l√† est <strong>un
message d&#39;erreur</strong>. C&#39;est un des grands avantages de la programmation. Lorsqu&#39;on
fait une erreur, il y a g√©n√©ralement un message d&#39;erreur pour nous aider √† la
corriger. Il est important d&#39;apprendre √† lire ces messages car <strong>toute
l&#39;information</strong> dont on a besoin pour <strong>corriger</strong> l&#39;erreur se trouve
g√©n√©ralement <strong>dans le message</strong>.</p>
<p>Ici le message d&#39;erreur nous indique que le probl√®me se trouve dans le fichier
<code>2nd_order.py</code> √† la <strong>ligne 1</strong>. Le caract√®re <code>^</code> indique √† quel endroit de la
ligne se trouve l&#39;erreur. Et la derni√®re ligne du message est <strong>une description
de l&#39;erreur</strong>. Ici, on nous dit que le nom <code>b</code> n&#39;est pas d√©fini.</p>
<p>En effet, nous n&#39;avons, dans ce programme, pas d√©fini <strong>les valeurs</strong> de <code>a</code>,
<code>b</code> et <code>c</code>. Python ne peut donc pas effectuer le calcul <code>b*b-4*a*c</code>. Le message
d&#39;erreur nous parle de <code>b</code> car c&#39;est la premi√®re variable non d√©finie qu&#39;il
rencontre.</p>
<p>Ajoutons des d√©finitions pour ces 3 variables&nbsp;:</p>
<figure id='python_2deg_corrected' data-ref='code'>

<pre><code class="language-python">a = 1
b = 0
c = -4
D = b*b-4*a*c
if D &lt; 0:
    print(&quot;Pas de solution r√©elle&quot;)
else:
    if D == 0:
        print(&quot;La racine double est&quot;, -b/(2*a))
    else:
        print(&quot;La 1re racine est&quot;, (-b-sqrt(D))/(2*a))
        print(&quot;La 2e racine est&quot;, (-b+sqrt(D))/(2*a))
</code></pre>
<figcaption>d√©finitions des valeurs <code>a</code>, <code>b</code> et <code>c</code></figcaption>
</figure>

<p>Relan√ßons le programme&nbsp;:</p>
<pre class="terminal" style="font-size: 85%">
<b>> python 2nd_order.py</b>
Traceback (most recent call last):
  File "C:\Users\lur\Programmation\2nd_order.py", line 11, in &lt;module&gt;
    print("La 1re racine est", (-b-sqrt(D))/(2*a))
                                   ^^^^
NameError: name 'sqrt' is not defined
</pre>

<p>Encore une erreur, la fonction <code>sqrt()</code> qui permet de calculer les racines
carr√©es n&#39;est pas charg√©e par d√©faut en Python. Comme nous ne l&#39;avons pas
charg√©e, le nom <code>sqrt</code> n&#39;est pas d√©fini. Ajoutons <strong>l&#39;importation</strong> de la
fonction <code>sqrt</code>&nbsp;:</p>
<figure id='python_2deg_corrected_2' data-ref='code'>

<pre><code class="language-python">from math import sqrt

a = 1
b = 0
c = -4
D = b*b-4*a*c
if D &lt; 0:
    print(&quot;Pas de solution r√©elle&quot;)
else:
    if D == 0:
        print(&quot;La racine double est&quot;, -b/(2*a))
    else:
        print(&quot;La 1re racine est&quot;, (-b-sqrt(D))/(2*a))
        print(&quot;La 2e racine est&quot;, (-b+sqrt(D))/(2*a))
</code></pre>
<figcaption>Importation de la fonction <code>sqrt</code></figcaption>
</figure>

<p>Relan√ßons le programme&nbsp;:</p>
<pre class="terminal">
<b>> python 2nd_order.py</b>
La 1re racine est -2.0
La 2e racine est 2.0
</pre>

<p><strong>Et voil√† !</strong> √áa marche.</p>
<p>Nous avons eu ici un exemple classique de r√©daction de programme. <strong>On √©crit du
code, on teste, on lit les messages d&#39;erreur, on corrige et on recommence.</strong></p>
<script type="module" defer>
  fetch("https://endoflife.date/api/python.json")
    .then((response) => response.json())
    .then((data) => {
      const version = data[0].latest;
      const shortVersion = version.split(".").slice(0, 2).join(".");
      const pathVersion = shortVersion.split(".").join("")
      document.querySelectorAll(".pyversion").forEach((elem) => {
        elem.innerHTML = version;
      });
      document.querySelectorAll(".pyshortversion").forEach((elem) => {
        elem.innerHTML = shortVersion;
      });
      document.querySelectorAll(".pypathversion").forEach((elem) => {
        elem.innerHTML = pathVersion;
      });
    });
</script>

</body>
</html>
